<?xml version="1.0" encoding="utf-8"?>
<!--
***********************************************************************************************
MSBuild.Sdk.Extras.JSL.Tasks.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) wherewhere. All rights reserved.
***********************************************************************************************
-->
<Project>

  <UsingTask
    TaskName="RemoveReferencePath"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <ReferencePath ParameterType="System.String[]" Required="true" />
      <References ParameterType="System.String[]" Output="true" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            if (ReferencePath == null)
            {
                return _Success;
            }

            try
            {
                string[] removes = new string[] { "vjslib.dll", "vjscor.dll", "vjslibcw.dll", "mscorlib.dll", "System.dll" };
                List<string> references = new List<string>(ReferencePath);
                references.RemoveAll(x => Array.Exists(removes, y => x.EndsWith(y, StringComparison.OrdinalIgnoreCase)));
                References = references.ToArray();
                _Success = true;
            }
            catch (Exception)
            {
                Log.LogError("Failed to remove ReferencePath.");
                _Success = false;
            }
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <UsingTask
    TaskName="FormatStringArray"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <StringArray ParameterType="System.String[]" Required="true" />
      <Format ParameterType="System.String" Required="true" />
      <Results ParameterType="System.String[]" Output="true" />
    </ParameterGroup>
    <Task>
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            if (StringArray == null)
            {
                return _Success;
            }

            try
            {
                Results = StringArray.Select(x => string.Format(Format, x)).ToArray();
                _Success = true;
            }
            catch (Exception)
            {
                Log.LogError("Failed to format " + Format + " .");
                _Success = false;
            }
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <UsingTask
    TaskName="WriteJSLCodeFragment"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <AssemblyAttributes ParameterType="Microsoft.Build.Framework.ITaskItem[]" />
      <OutputDirectory ParameterType="Microsoft.Build.Framework.ITaskItem" />
      <OutputFile ParameterType="Microsoft.Build.Framework.ITaskItem" Output="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Security" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
            if (OutputFile == null && OutputDirectory == null)
            {
                Log.LogErrorWithCodeFromResources("WriteCodeFragment.MustSpecifyLocation");
                _Success = false;
                return _Success;
            }

            StringBuilder code = new StringBuilder(
@"//------------------------------------------------------------------------------
/// <autogenerated>
///     This code was generated by a tool.
///     Runtime Version: ").AppendLine(Environment.Version.ToString()).Append(
@"///
///     Changes to this file may cause incorrect behavior and will be lost if 
///     the code is regenerated.
/// </autogenerated>
//------------------------------------------------------------------------------

import System.*;
import System.Reflection.*;

");

            foreach (ITaskItem attributeItem in AssemblyAttributes)
            {
                // Some attributes only allow positional constructor arguments, or the user may just prefer them.
                // To set those, use metadata names like "_Parameter1", "_Parameter2" etc.
                // If a parameter index is skipped, it's an error.
                IDictionary customMetadata = attributeItem.CloneCustomMetadata();
                code.Append("/** @assembly ").Append(attributeItem.ItemSpec).Append("(");
                List<string> parameters = new List<string>();
                if (attributeItem.ItemSpec.EndsWith("VersionAttribute", StringComparison.OrdinalIgnoreCase))
                {
                    var index = 0;
                    foreach (DictionaryEntry entry in customMetadata)
                    {
                        if (index++ == 0)
                        {
                            var versions = entry.Value.ToString().Split('.');
                            if (versions.Length < 4)
                            {
                                var version = new[] { "0", "0", "0", "0"};
                                int i = 0, j = 3;
                                foreach (var v in versions)
                                {
                                    int a;
                                    if (int.TryParse(v, out a))
                                    {
                                        version[i++] = v;
                                    }
                                    else
                                    {
                                        version[j--] = v;
                                    }
                                    if (i > j) { break; }
                                }
                                parameters.Add('\"' + string.Join(".", version) + '\"');
                            }
                            else
                            {
                                parameters.Add('\"' + entry.Value.ToString() + '\"');
                            }
                        }
                        else
                        {
                            parameters.Add('\"' + entry.Value.ToString() + '\"');
                        }
                    }
                }
                else
                {
                    foreach (DictionaryEntry entry in customMetadata)
                    {
                        parameters.Add('\"' + entry.Value.ToString() + '\"');
                    }
                }
                code.Append(string.Join(", ", parameters));
                code.AppendLine(") */");
            }
            
            code.AppendLine().AppendLine("// Generated by the MSBuild.Sdk.Extras.JSL WriteJSLCodeFragment class.");

            if (code.Length == 0)
            {
                Log.LogMessageFromResources(MessageImportance.Low, "WriteCodeFragment.NoWorkToDo");
                OutputFile = null;
                return _Success;
            }

            try
            {
                if (OutputFile != null && OutputDirectory != null && !Path.IsPathRooted(OutputFile.ItemSpec))
                {
                    OutputFile = new TaskItem(Path.Combine(OutputDirectory.ItemSpec, OutputFile.ItemSpec));
                }
                
                if (OutputFile == null)
                {
                    string extension = ".cs";
                    
                    try
                    {
                        string directory = OutputDirectory.ItemSpec;

                        // If the extension needs a dot prepended, do so.
                        if (extension == null)
                        {
                            extension = string.Empty;
                        }
                        else if (extension.Length > 0 && extension[0] != '.')
                        {
                            extension = '.' + extension;
                        }

                        // If the fileName is null, use tmp{Guid}; otherwise use fileName.
                        string fileName = "tmp" + Guid.NewGuid().ToString("N");

                        Directory.CreateDirectory(directory);

                        string file = Path.Combine(directory, fileName + extension);

                        if (!File.Exists(file))
                        {
                            throw new Exception("Guid should be unique");
                        }

                        File.WriteAllText(file, string.Empty);

                        OutputFile = new TaskItem(file);
                    }
                    catch (Exception ex)
                    {
                        if (ex is UnauthorizedAccessException
                            || ex is NotSupportedException
                            || (ex is ArgumentException && !(ex is ArgumentNullException))
                            || ex is SecurityException
                            || ex is IOException)
                        {
                            throw new IOException(string.Format("MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}", ex.Message), ex);
                        }
                        else
                        {
                            throw;
                        }
                    }
                }

                string directoryPath = Path.GetDirectoryName(OutputFile.ItemSpec);
                if (!string.IsNullOrEmpty(directoryPath) && !Directory.Exists(directoryPath))
                {
                    Directory.CreateDirectory(directoryPath);
                }

                File.WriteAllText(OutputFile.ItemSpec, code.ToString()); // Overwrites file if it already exists (and can be overwritten)
            }
            catch (Exception ex)
            {
                if (ex is UnauthorizedAccessException
                    || ex is NotSupportedException
                    || (ex is ArgumentException && !(ex is ArgumentNullException))
                    || ex is SecurityException
                    || ex is IOException)
                {
                    Log.LogErrorWithCodeFromResources("WriteCodeFragment.CouldNotWriteOutput", (OutputFile == null) ? String.Empty : OutputFile.ItemSpec, ex.Message);
                    return false;
                }
                else
                {
                    throw;
                }
            }

            Log.LogMessageFromResources(MessageImportance.Low, "WriteCodeFragment.GeneratedFile", OutputFile.ItemSpec);

            _Success = !Log.HasLoggedErrors;
        ]]>
      </Code>
    </Task>
  </UsingTask>

</Project>